########################################################
# Documentació i referència
######################################################## 

# Breu descripció de cada programa

  -camera: 
  -compass: llegeix brúixola. Fer servir sensor.c en comptes d'aquest.
  -do_nothing: fa la posició inicial (action_set_page(31)) i no fa res més.
  -gir: Programa per fer debug de la brúixola. Fixa una direcció inicial i quan el gires hi torna
  -intent_laberint: Ara per ara camina cap a l'esquerra fins que troba una paret i en trobar-la torna cap a la dreta fins que en troba una altre.
  -movements: Programa per provar moviments
  -sensor: fa lectures de qualsevol dels sensors i les imprimeix per serial
  -vision: Ara per ara és un INTENT de fer girar el robot 45 graus amb una mica de precisió
  -walk_correction: Fa caminar el robot recte corregint segons el compass (no acaba d'encadenar bé els moviments)
  -walk_correction2: Versió del walk_correction utilitzant funcions extranyes
  -walk_forward/walk_forward2: Fan caminar el robot recte sense modificacions


A cada programa, després de les llibreries hi ha una petita explicació més específica.

# Coses a tenir en compte:

  -Hi ha 2 funcions turn_angle(), una a /examples/walk_straight/walk_straight.c i una altra a /motion/src/mtn_library.c. En principi nosaltres fem servir la de mtn_library.c. S'ha de tenir en compte que turn_angle() de mtn_library.c agafa un angle en un rang d'entre [0, 360] (que després multiplica per 10), i no de [0, 3600] com se suposa que dona la brúixola.
  
  -A /motion/src/mtn_library.c hi ha la funció walk_forward_compensating(), que entenem que fa el que pretenem fer nosaltres a walk_corretion.c i walk_correction2.c, pot ser útil.
  
  -Si es vol modificar els offsets (normalment per canviar la inclinació del robot), s'ha de fer a /motion/src/balance.c. En el propi fitxer ja hi ha comentaris sobre com fer-ho. Un com modificat l'arxiu de balance.c, cal fer un make a /motion i tornar a fer un make en el directori del programa que s'està intentant compilar. Ara mateix hi ha un offset de 30 graus a cadascun dels genolls del robot perquè sense offsets ell mateix es tirava enrere i queia. És importatn saber que les els motors es posicionen segons els offsets fins i tot abans d'apretar START i executar la pàgina 31.
  
  -Si es vol modificar les definicions del robot al simulador, primer cal modificar l'arxiu bioloid_ceabot.xacro (/home/humanoides/iri-lab/iri_ws/src/bioloid_robot/bioloid_description/urdf/bioloid_ceabot.xacro) i després l'arxiu bioloid_ceabot.yaml (/iri-lab/iri_ws/src/bioloid_robot/bioloid_control/config/bioloid_ceabot.yaml). Exemple pel sensor de IR:
  
  <xacro:sharp_ir name="nom" parent="a on s'enganxa" update_rate="20" fov="0.05" min_range="0.1" max_range="0.8">
    <origin xyz="posoció realtiva a parent (x y z)" rpy="orientació (x y z)" />
  </xacro:sharp_ir>
  
  -Cal tenir en compte que els ports del simulador van un port enrere, és a dit, que el port ADC7 en el simulador és el ADC6.
  
  -Es pot canviar de compass a bno055 des del Makefile de bioloid_exp_board_fw (Posteriorment s'ha de fer un make clean i make)
  
  -Els giroscopis en el nostre robot per defecte estan al revés. Els valor correcte per a cada port és: 4 pel gyro de l'eix X i 3 pel gyro de l'eix Y. Aquesta configuració es pot canviar a cm510_controller_fw/controller/include/cm510_cfg.h Després de modificar aquest fitxer, per tal que tingui efecte cal fer un make clean i make des de cm510_controller_fw/controller/
  
  -Per esperar un temps, no és suficient utilitzar la funció user_time_set_period(n), aquesta només posa el rellorge del robot a un temps determinat, i s'ha de comprovar manualment si aquest temps ha passat. Per fer-ho, hi ha la funció user_time_is_period_done(), que retorna true si ha passat els n milisegons definits per user_time_set_period(n) i false en cas contrari. Hi ha un exemple funcional d'això a /Bioloid_General_ceabot2017/sensor/sensor.c.
  
  -S'ha enganxat una mica de cinta adhesiva als peus del robot per augmentar la fricció i fer que no rellisqui. Això pot (s'ha de comprovar) afectar als moviments, ja que hi ha la possibilitat de que algun d'aquests arrossegui els peus.
  
  -Per definir els offsets ja no s'utilitza balance.c, sinó que hi ha un programa per fer-ho. Carregar l'exemple slave al robot:
    - Anar a cm510_controller_fw/examples/slave/
    - make clean
    - make
    - sudo modprobe ftdi_sio
    - make download
    
    Encendre la utilitat de definir offsets
    - Anar a bioloid_robot_driver/build/
    - sudo rmmod ftdi_sio
    - Encendre el robot i esperar la lumeta verda
    - ../bin/bioloid_offset
    - Seguir les ordres de la pantalla
    
  -En general totes les funcions de moviment funcionen d'una manera especial: un com han acabat, retornen 0x01. Això vol dir que per executar-les, se les ha d'anar cridant constantment, tal com es feia fins ara. Si en algun moment es llença un mtn_lib_stop_mtn(), el moviment es comença a parar, però s'ha d'anar cridant de la mateixa manera fins que para. S'ha de tenir en compte que quan es fa un "if(walk_forward() == 0x01)", també s'està cridant la funció, i de fet la majoria de vegades es voldrà fer d'aquesta manera. Aquí hi ha un exemple mínim del funcionament:

    case walk: if(is_button_rising_edge(BTN_DOWN))
	       {
		 mtn_lib_stop_mtn();
	       }
	       
	       if(walk_forward() == 0x01) //Només es crida la funció quan es comprova si retorna 0x01
	       {
		 state = stop;
	       }
	       else
	       {
		 state = walk;
	       }
	       break;	      
		  
		    
      case stop: if(is_button_rising_edge(BTN_UP))
		{
		  state = wait_ready;
		}
		else
		{
		  state = stop;
		}
		break;
		
  En aquest exemple (que no és funcional) mentre no s'apreti el botó avall, s'anirà comprovant si el moviment ha acabat, a l'hora que es crida la funció de caminar. Si s'apreta el botó, el moviment no acabarà d'immediat, sinó que ho farà de manera que acabi amb els dos peus junts. De fet, encara que s'hagi apretat el botó, es continuarà cridant la funció de caminar fins que retorni 0x01, indicant que ha acabat. En aquest punt s'anirà a l'estat stop, on s'esperarà que es premi el botó cap amunt per a continuar el moviment.
    
  
  
  
# Sensors

  -Compass: teòricament té un rang de [0, 3600]. S'ha de vigilar perquè algunes funcions agafen un rang de [0, 360].
  
  -bno055 (substitueix compass): té un rang de [-1800, 2000] (sí, una mica curiós), però en principi no ha de donar problemes perquè mai s'hauria de desviar tant. Tal com passava amb compass, algunes funcions utilitzen aquest rang dividit entre 10.
  
  -IR: Rang de [82, 500] per al de llarga distància (aproximadament). Com més pròxim és l'objecte, més augmenta el valor, encara que a uns 5 o 6 cm del sensor el valor torna a decrèixer al apropar l'objecte.
  
  -Gyro: Mesuren velocitat angular en º/s (?) amb un rang de [45, 455]. S'ha de vigilar perquè a vegades el giroscopi que monitoritza l'eix x està connectat al port de l'eix y i al revés.
  
  Si els sensors retornen sempre valors incoherents i fixos, el més probable és que s'haigi de reescriure el firmware de la placa d'expansió. Hi ha documentació del procediment a l'apartat 5.1 del document Humanoids.pdf, (../Humanoids.pdf).
  
# Preguntes
  
   Q:walk_forward() fa una passa o camina indefinidament? 
   A:fa només una passa, per tal d'aconseguir moviment continuat s'ha d'anar cridant constantment.
   
   Q: mtn_lib_stop_mtn() què fa exactament? Acaba el moviment en sec o el finalitza i el posa en una posició bona per començar l'altre moviment?
   A: En principi para sobtadament. Suposem que els enllaços entre moviments són dins de les pròpies funions de moviments. Cal investigar-ho més.
   
   Q:Com podem fer els moviments fluids? Com els hem d'encadenar? Com podem fer que acabin i no en comenci un altre fins que la posició per fer-ho no sigui la bona?
   A: Una manera molt senzilla és fent servir les funcions que acaben en _compensating. Aquestes treballen en més baix nivell utilitzant les pàgines directament, i llavors són molt més fluids, ràpids i precisos.
